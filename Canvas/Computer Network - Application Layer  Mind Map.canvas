{
	"nodes":[
		{
			"id":"36cf55a528108ada",
			"type":"group",
			"styleAttributes":{},
			"x":2181,
			"y":2360,
			"width":3939,
			"height":4200,
			"color":"5",
			"label":" world-wide-web"
		},
		{
			"id":"ba612aa05bdea840",
			"type":"group",
			"styleAttributes":{},
			"x":3220,
			"y":8660,
			"width":1262,
			"height":1320,
			"color":"5",
			"label":"MAA"
		},
		{
			"id":"6f0b3f8ffd61203b",
			"type":"group",
			"styleAttributes":{},
			"x":1460,
			"y":140,
			"width":1317,
			"height":871,
			"color":"5",
			"label":"socket"
		},
		{
			"id":"d84fdfb520a86310",
			"type":"group",
			"styleAttributes":{},
			"x":556,
			"y":228,
			"width":845,
			"height":1152,
			"color":"5",
			"label":" Client-Server-Paradigm"
		},
		{
			"id":"912f595d46388ad3",
			"type":"group",
			"styleAttributes":{},
			"x":3257,
			"y":3680,
			"width":1365,
			"height":680,
			"color":"5",
			"label":"Types of HTTP Connection"
		},
		{
			"id":"45ab0c338b661c4b",
			"type":"group",
			"styleAttributes":{},
			"x":1802,
			"y":1174,
			"width":758,
			"height":946,
			"color":"5",
			"label":" TCP-Protocols"
		},
		{
			"id":"c3107ec0630a9f66",
			"type":"group",
			"styleAttributes":{},
			"x":-680,
			"y":-740,
			"width":1120,
			"height":600,
			"color":"5",
			"label":"introduction"
		},
		{
			"id":"0369e8c87cc13453",
			"type":"group",
			"styleAttributes":{},
			"x":-180,
			"y":340,
			"width":630,
			"height":709,
			"color":"5",
			"label":"introduction"
		},
		{
			"id":"5a7be39ba04c3912",
			"type":"text",
			"text":"### Standard and Nonstandard Protocols\n\nIn the context of the application layer, there are two types of protocols: standard and nonstandard.",
			"styleAttributes":{},
			"x":-660,
			"y":-537,
			"width":360,
			"height":180,
			"color":"1"
		},
		{
			"id":"6ca6feaaed0a5625",
			"type":"text",
			"text":"**Standard Application-Layer Protocols**: These protocols are standardized and documented by Internet authorities and are included in operating systems like Windows and UNIX. Examples include HTTP (for web browsing), FTP (for file transfer), and SMTP (for email). Standard protocols are essential for smooth Internet operations and are widely used in daily interactions with the Internet. Understanding these protocols helps network managers troubleshoot issues and also inspires the development of new protocols.",
			"styleAttributes":{
				"shape":null
			},
			"x":-220,
			"y":-720,
			"width":640,
			"height":240,
			"color":"6"
		},
		{
			"id":"a078b64a872808e9",
			"type":"text",
			"text":"### E-Mail Architecture\n\nThe architecture of e-mail systems is designed to handle the asynchronous nature of communication, allowing users to send and receive messages even when they are not continuously connected to the network. The process involves multiple components, including User Agents (UAs), Mail Transfer Agents (MTAs), and Message Access Agents (MAAs).\n\n#### Common Scenario\nIn a typical scenario:\n- **Alice (Sender)** and **Bob (Receiver)** are connected to their respective mail servers via a **LAN** (Local Area Network) or **WAN** (Wide Area Network).\n- Each user has a **mailbox** on their respective mail server, where received messages are stored. The mailbox is a part of the server's hard drive, secured with permission restrictions that only allow the owner to access it.\n- The mail server also has a **queue (spool)** to store messages waiting to be sent.\n\n#### Steps in E-Mail Transmission\nA simple e-mail exchange between Alice and Bob involves nine steps:\n1. **Alice creates the message using a User Agent (UA).**\n2. **The message is sent to Alice's mail server**, where it is stored in a spool (queue) until it can be delivered.\n3. **Alice's mail server initiates the transfer using a Mail Transfer Agent (MTA) client.**\n4. **The MTA client sends the message over the Internet to Bob's mail server,** where an MTA server receives it.\n5. **Bob's mail server stores the message in Bob's mailbox.**\n6. **Bob's User Agent (UA)** is used to check for new messages.\n7. **Bob retrieves the message using a Message Access Agent (MAA) client,** which pulls the message from the MAA server running on Bob's mail server.\n8. **Bob reads the message.**\n9. **The MAA client continues to check for new messages periodically.**\n\n#### Important Points:\n1. **MTA Server Operation:** Bob cannot bypass the mail server to directly use the MTA server, as doing so would require Bob to run the MTA server all the time. This setup would be impractical because Bob would have to keep his computer on constantly if connected via LAN or keep his WAN connection active continuously.\n\n2. **Push and Pull Mechanism:** The MTA system operates on a **push mechanism**, where the MTA client pushes messages to the server. However, Bob's side needs a **pull mechanism** through the MAA, where the client pulls messages from the server to allow Bob to access them.\n\nThis architecture efficiently manages the asynchronous nature of e-mail communication, enabling messages to be stored and retrieved even when users are not continuously online.",
			"styleAttributes":{},
			"x":1960,
			"y":6840,
			"width":988,
			"height":591,
			"color":"2"
		},
		{
			"id":"c012cda824b37967",
			"type":"text",
			"text":"### User Agent (UA)\n\nThe **User Agent (UA)** is a critical component of an e-mail system, serving as the interface between the user and the e-mail system. It simplifies the process of sending and receiving messages, allowing users to manage their e-mail effectively.\n\n#### Types of User Agents\n1. **Command-driven User Agents:**\n   - Belong to the early days of e-mail.\n   - Accept one-character commands from the keyboard for tasks like replying to or forwarding messages.\n   - Examples: `mail`, `pine`, `elm`.\n\n2. **GUI-based User Agents:**\n   - Feature graphical components like icons, menus, and windows.\n   - Allow interaction via both keyboard and mouse, making tasks more accessible.\n   - Examples: `Eudora`, `Outlook`.\n\n#### Sending Mail\nWhen sending an e-mail, the process involves creating a message similar to postal mail, consisting of:\n- **Envelope:** Contains the sender's and receiver's addresses and other routing information.\n- **Message:** Divided into two parts:\n  - **Header:** Includes information like the sender's address, receiver's address, subject, and date.\n  - **Body:** Contains the actual message content.\n\n#### Receiving Mail\nWhen receiving e-mail, the UA can be triggered manually by the user or automatically by a timer. Upon receiving new messages:\n- The UA notifies the user.\n- A summary of the messages, including the sender's address, subject, and timestamp, is displayed.\n- The user can select a message to view its content.\n\n### E-Mail Addresses\nE-mail addresses consist of two parts:\n1. **Local Part:** Represents the user's mailbox on the mail server.\n2. **Domain Name:** Identifies the mail server or exchanger responsible for receiving and sending e-mails, often derived from the DNS database or assigned as a logical name by the organization.\n\n### Mailing List (Group List)\nA **mailing list** (or group list) allows a single alias to represent multiple e-mail addresses. When sending a message to an alias, the system checks the alias database and sends individual messages to each address in the list.\n\nThis architecture ensures efficient handling of e-mails, making it easier for users to send, receive, and manage their messages.",
			"styleAttributes":{},
			"x":1960,
			"y":7520,
			"width":988,
			"height":420,
			"color":"2"
		},
		{
			"id":"5ad1a09e4b60a0a9",
			"type":"text",
			"text":"### Message Transfer Agent (MTA) and SMTP\n\nThe **Message Transfer Agent (MTA)** is responsible for transferring e-mail messages from the sender's server to the recipient's server. The **Simple Mail Transfer Protocol (SMTP)** is the formal protocol used by MTAs to facilitate this process on the Internet. SMTP ensures that commands and responses are exchanged correctly between the MTA client (the sender's server) and the MTA server (the recipient's server).\n\n#### Three Client-Server Paradigms in E-Mail\n\nE-mail requires three distinct uses of the client-server paradigm:\n1. **MTA Client and MTA Server (Sender to Sender's Mail Server):** The sender's e-mail client sends the message to the sender's mail server using SMTP.\n2. **MTA Client and MTA Server (Between Mail Servers):** The sender's mail server transfers the message to the recipient's mail server using SMTP.\n3. **Message Access Agent (MAA):** This occurs between the recipient's mail server and the recipient's e-mail client. Protocols like POP (Post Office Protocol) or IMAP (Internet Message Access Protocol) are used here to retrieve the message.\n\n#### Commands and Responses in SMTP\n\nSMTP communication consists of commands sent by the MTA client and responses from the MTA server. Each command is followed by arguments and is terminated by a carriage return and line feed (CRLF). \n\n- **Commands:** SMTP defines 14 commands (e.g., HELO, MAIL FROM, RCPT TO, DATA, QUIT) used to perform different tasks during the e-mail transfer process.\n  \n  **Examples:**\n  - `HELO <Sender's Host Name>`: Identifies the sender's host.\n  - `MAIL FROM <Sender's Email>`: Specifies the sender's e-mail address.\n  - `RCPT TO <Recipient's Email>`: Identifies the recipient's e-mail address.\n  - `DATA`: Sends the actual message content.\n  - `QUIT`: Terminates the SMTP session.\n\n- **Responses:** The server responds with a three-digit code followed by additional textual information. Responses indicate the status of the command execution.\n\n  **Examples:**\n  - `250`: Command completed successfully.\n  - `354`: Start mail input (initiates data transfer).\n  - `421`: Service not available (transient error).\n  - `550`: Command not executed (permanent error, such as mailbox unavailable).",
			"styleAttributes":{},
			"x":1960,
			"y":8040,
			"width":988,
			"height":520,
			"color":"2"
		},
		{
			"id":"4fcf5ba121484db9",
			"type":"text",
			"text":"### Mail Transfer Phases in SMTP\n\nThe process of transferring an e-mail message via SMTP involves three distinct phases: **Connection Establishment, Mail Transfer, and Connection Termination**.\n\n#### 1. Connection Establishment\nThis phase begins when the SMTP client (e.g., the sender's mail server) initiates a TCP connection to the SMTP server (e.g., the recipient's mail server) on the well-known port 25. The steps are as follows:\n\n1. **Server Ready (220)**: Upon establishing the connection, the SMTP server sends the response code **220** (service ready) to indicate that it is ready to receive mail. If the server is not available, it sends the response code **421** (service not available).\n\n2. **Client Identification (HELO)**: The SMTP client identifies itself by sending the **HELO** command along with its domain name. This step informs the server about the client's domain name.\n\n3. **Server Acknowledgment (250)**: The server responds with the code **250** (request command completed) to acknowledge the client's identification. If there are any issues, it may send a different appropriate code.\n\n#### 2. Mail Transfer\nOnce the connection is established, the actual e-mail message is transferred from the client to the server. This phase involves eight steps:\n\n1. **Sender Introduction (MAIL FROM)**: The client sends the **MAIL FROM** command, specifying the sender's e-mail address. This step is necessary to provide the server with a return address for error reporting and delivery status notifications.\n\n2. **Server Acknowledgment (250)**: The server responds with code **250** (request command completed) to acknowledge the sender's information.\n\n3. **Recipient Introduction (RCPT TO)**: The client sends the **RCPT TO** command, specifying the recipient's e-mail address.\n\n4. **Server Acknowledgment (250)**: The server responds with code **250** (request command completed) to acknowledge the recipient's information.\n\n   - **Note**: Steps 3 and 4 are repeated if there are multiple recipients.\n\n5. **Data Transfer Initialization (DATA)**: The client sends the **DATA** command to initiate the transfer of the actual message content.\n\n6. **Server Response (354)**: The server responds with code **354** (start mail input) to indicate that it is ready to receive the message content.\n\n7. **Message Content Transfer**: The client sends the message content line by line, with each line terminated by a carriage return and line feed (CRLF). The message is concluded with a line containing just a single period (`.`) to signal the end of the message.\n\n8. **Server Acknowledgment (250)**: After successfully receiving the message, the server responds with code **250** (OK) to confirm the completion of the message transfer.\n\n#### 3. Connection Termination\nAfter the successful transfer of the message, the connection between the client and the server is terminated in two steps:\n\n1. **Client Termination (QUIT)**: The client sends the **QUIT** command to signal the end of the session.\n\n2. **Server Response (221)**: The server responds with code **221** (service closing transmission channel) to acknowledge the termination of the connection. The connection is then closed.\n\n### Example 2.13: Mail Transfer Steps\n\nTo illustrate these phases, consider a typical scenario where an e-mail is sent from the sender to the local mail server and then from the local mail server to the remote mail server. The process repeats twice: once from the sender's client to the local server and once from the local server to the remote server.\n\n1. **First Transfer**: \n   - The e-mail client connects to the local mail server.\n   - The connection is established, and the message is transferred following the steps outlined in the Mail Transfer phase.\n   - The local mail server may spool the message and decide to send it to the remote mail server later.\n\n2. **Second Transfer**:\n   - The local mail server connects to the remote mail server.\n   - The message is transferred again, following the same steps, until it reaches the recipient's mail server.\n\nThrough these steps, the e-mail message is reliably delivered from the sender to the recipient, even if multiple servers are involved in the transfer process.",
			"styleAttributes":{},
			"x":3262,
			"y":8040,
			"width":1200,
			"height":520,
			"color":"3"
		},
		{
			"id":"6f3f8f8e0eff7435",
			"type":"file",
			"file":"source-images/Pasted image 20240913114454.png",
			"styleAttributes":{},
			"x":4289,
			"y":6840,
			"width":874,
			"height":890
		},
		{
			"id":"ebceefbd20ad1676",
			"type":"text",
			"text":"Here's a simplified breakdown of the SMTP process:\n\n### 1. **Connection Establishment:**\n   - **Step 1:** Server sends code 220 (ready) or 421 (not ready).\n   - **Step 2:** Client sends \"HELO\" with its domain name.\n   - **Step 3:** Server responds with code 250 (OK) or other code.\n\n### 2. **Message Transfer:**\n   - **Step 1:** Client sends \"MAIL FROM\" with sender's address.\n   - **Step 2:** Server responds with code 250 or other code.\n   - **Step 3:** Client sends \"RCPT TO\" with recipient's address.\n   - **Step 4:** Server responds with code 250 or other code.\n   - **Step 5:** Client sends \"DATA\" to start the message.\n   - **Step 6:** Server responds with code 354 (start message).\n   - **Step 7:** Client sends the message, ending with a line containing just a period.\n   - **Step 8:** Server responds with code 250 (OK) or other code.\n\n### 3. **Connection Termination:**\n   - **Step 1:** Client sends \"QUIT.\"\n   - **Step 2:** Server responds with code 221 (closing connection).",
			"styleAttributes":{},
			"x":3099,
			"y":6840,
			"width":1141,
			"height":890,
			"color":"2"
		},
		{
			"id":"1899c956b2cf869c",
			"type":"text",
			"text":"###  Electronic Mail\n\n**Electronic mail (e-mail)** allows users to exchange messages, but the way it operates is quite different from other client-server applications like HTTP or FTP. Unlike those services, where the server is always running and waiting for client requests to respond to, e-mail works on a one-way transaction basis. Here’s how:\n\n1. **One-Way Transaction**: When a user, say Alice, sends an e-mail to another user, Bob, she is initiating a one-way transaction. Alice sends the message without necessarily expecting an immediate response. If Bob does reply, it becomes a separate one-way transaction.\n\n2. **No Continuous Server Connection**: Unlike applications where a server continuously waits for incoming client requests, the nature of e-mail communication does not require the recipient to be always online. For instance, Bob may have his computer turned off or not running any specific server program to handle incoming e-mails when Alice sends her message.\n\n3. **Intermediate Servers**: Instead of Bob running a server to receive messages at all times, e-mail systems use intermediate servers to manage the exchange. These servers store the messages until Bob or any recipient is ready to access them. \n\nWhen users want to send or receive e-mails, they run client programs (like email applications), and the intermediate servers handle the client/server interactions behind the scenes.\n\nThis structure ensures that e-mail can be sent and received even when the recipient is not online or available, providing flexibility in communication without requiring continuous connectivity between the sender and receiver.",
			"styleAttributes":{},
			"x":420,
			"y":6840,
			"width":1251,
			"height":500,
			"color":"6"
		},
		{
			"id":"d6913325504cb209",
			"type":"file",
			"file":"source-images/Pasted image 20240901112548.png",
			"styleAttributes":{},
			"x":535,
			"y":7560,
			"width":1136,
			"height":580,
			"color":"2"
		},
		{
			"id":"f326a2acc892975b",
			"type":"file",
			"file":"source-images/Pasted image 20240901114001.png",
			"styleAttributes":{},
			"x":481,
			"y":8300,
			"width":1244,
			"height":380
		},
		{
			"id":"d3151340a6379e96",
			"type":"text",
			"text":"### Message Access Agent: POP and IMAP\n\nIn email communication, the process of delivering a message involves three stages:\n\n1. **First Stage:** The email client sends the message to the outgoing mail server using SMTP (Simple Mail Transfer Protocol).\n2. **Second Stage:** The outgoing mail server sends the message to the recipient's incoming mail server using SMTP.\n3. **Third Stage:** The recipient retrieves the message from their incoming mail server. This stage requires a message access protocol.\n\nThe third stage requires a **pull protocol** because the client (recipient) needs to pull messages from the server, in contrast to SMTP, which is a push protocol that sends messages from the client to the server. The two main protocols used for message access are **Post Office Protocol version 3 (POP3)** and **Internet Mail Access Protocol version 4 (IMAP4)**.",
			"styleAttributes":{},
			"x":1960,
			"y":8680,
			"width":988,
			"height":360,
			"color":"2"
		},
		{
			"id":"358d37436ccbcb44",
			"type":"text",
			"text":"## DNS\n\nThe Domain Name System (DNS) is a critical component of the Internet's infrastructure, allowing human-readable domain names (like `example.com`) to be translated into IP addresses, which are necessary for network communication. Without DNS, users would have to memorize complex IP addresses to access websites and services, rather than simply typing in a domain name.\n\n### Key Concepts of DNS\n\n1. **Distributed System**: DNS is a distributed directory system that resolves domain names into IP addresses. The information is spread across multiple servers globally, ensuring that the system remains resilient and scalable. This distribution also prevents any single point of failure, which would be a risk if all DNS information were stored in a central directory.\n\n2. **DNS Client and Server Interaction**: When a user wants to connect to a server using a domain name, a process involving both DNS clients and servers is initiated. The steps are as follows:\n   - **User Request**: The user provides the domain name (e.g., `filesource.com`) to an application like a file transfer client.\n   - **DNS Query**: The application forwards this domain name to the DNS client on the user's device.\n   - **Query Forwarding**: The DNS client knows the IP address of a DNS server (often configured by the Internet Service Provider or manually by the user). The DNS client sends a query to this server, requesting the IP address corresponding to the domain name.\n   - **DNS Response**: The DNS server looks up the IP address associated with the domain name and sends this information back to the DNS client.\n   - **Address Forwarding**: The DNS client then passes the IP address to the application that originally requested it.\n   - **Connection Established**: Finally, the application uses this IP address to establish a connection with the desired server (e.g., for file transfer).\n\n### Importance of DNS\n\n- **Ease of Use**: DNS allows users to interact with services using domain names rather than IP addresses, making the Internet more user-friendly.\n- **Scalability**: The distributed nature of DNS ensures that it can handle the vast number of domain name queries generated by users worldwide.\n- **Resilience**: By distributing DNS information across multiple servers, the system avoids reliance on a single point of failure, increasing its reliability and uptime.\n\n### Two Connections in DNS\n\nIn scenarios involving DNS, at least two connections are typically required:\n- **DNS Lookup**: The first connection is between the DNS client and DNS server to resolve the domain name to an IP address.\n- **Service Connection**: The second connection is between the application (e.g., file transfer client) and the target server using the resolved IP address.\n\nIn some cases, more than one DNS lookup may be necessary if, for example, the DNS server needs to query other DNS servers to find the correct IP address.",
			"styleAttributes":{},
			"x":320,
			"y":10320,
			"width":1065,
			"height":560,
			"color":"6"
		},
		{
			"id":"ae3ac72c64a68d3a",
			"type":"text",
			"text":"The **Domain Name System (DNS)** utilizes a hierarchical name space to ensure the unique identification of entities across the Internet. Let's explore the key concepts of name space and domain name space:",
			"styleAttributes":{},
			"x":1440,
			"y":10320,
			"width":520,
			"height":120,
			"color":"2"
		},
		{
			"id":"cdd777d573f45fe0",
			"type":"file",
			"file":"source-images/Pasted image 20240901120902.png",
			"styleAttributes":{},
			"x":320,
			"y":11040,
			"width":1065,
			"height":521
		},
		{
			"id":"9bdb09bc9b3c96d1",
			"type":"file",
			"file":"source-images/Pasted image 20240901121536.png",
			"styleAttributes":{},
			"x":1505,
			"y":11080,
			"width":969,
			"height":440
		},
		{
			"id":"d9ebc934d82e6cdc",
			"type":"text",
			"text":"### POP3 (Post Office Protocol version 3)\n\n**POP3** is a simpler and more limited protocol. It works as follows:\n\n- The client (recipient) connects to the mail server using TCP port 110.\n- The client sends its username and password to access the mailbox.\n- The user can list and retrieve emails from the server.\n\nPOP3 operates in two modes:\n\n1. **Delete Mode:** Emails are deleted from the server after being downloaded to the client. This mode is typically used when the user is on their primary computer.\n2. **Keep Mode:** Emails remain on the server even after being downloaded, allowing the user to retrieve them later from other devices. This mode is useful when accessing email from different locations or devices.",
			"styleAttributes":{},
			"x":3262,
			"y":8680,
			"width":1200,
			"height":360,
			"color":"3"
		},
		{
			"id":"89f62c6019dff2d8",
			"type":"text",
			"text":"### IMAP4 (Internet Mail Access Protocol version 4)\n\n**IMAP4** is more advanced and offers additional features compared to POP3:\n\n- **Email Header Preview:** The user can check email headers before downloading the full message.\n- **Content Search:** The user can search for specific strings in the email before downloading.\n- **Partial Download:** The user can download only parts of the email, which is useful if bandwidth is limited.\n- **Server-Side Organization:** The user can create, delete, and rename mailboxes on the server.\n- **Folder Hierarchy:** The user can organize emails into folders and subfolders on the server.\n\nThese features make IMAP4 more powerful and flexible for managing emails on the server.",
			"styleAttributes":{},
			"x":3240,
			"y":9120,
			"width":1222,
			"height":320,
			"color":"3"
		},
		{
			"id":"1862480d07046e0a",
			"type":"text",
			"text":"### MIME (Multipurpose Internet Mail Extensions)\n\nMIME extends the capabilities of email by allowing non-ASCII data (e.g., text in other languages, binary files, images, video, and audio) to be sent through email. MIME transforms non-ASCII data into 7-bit ASCII data for transmission and then reverts it back to its original form at the recipient's end.\n\n**MIME Headers:**\n\n1. **MIME-Version:** Indicates the version of MIME (currently 1.1).\n2. **Content-Type:** Specifies the type of data (e.g., text, image, audio).\n3. **Content-Transfer-Encoding:** Describes how the data is encoded for transport.\n4. **Content-ID:** Uniquely identifies the message in a multi-message environment.\n5. **Content-Description:** Provides a description of the content (e.g., image, video).\n\nMIME uses different encoding methods, such as **Base64** (which converts 6-bit chunks of data into ASCII characters) and **Quoted-Printable** (which encodes non-ASCII characters as an equal sign followed by their ASCII code).",
			"styleAttributes":{},
			"x":3251,
			"y":9560,
			"width":1211,
			"height":400,
			"color":"3"
		},
		{
			"id":"deb8c5cb1d202a87",
			"type":"text",
			"text":"Here's why a **centralized name space** doesn't work for large systems like the Internet and why a **distributed, hierarchical system** is preferred, with examples:\n\n### 1. **Scalability Example**:\nImagine the entire Internet is managed by one central authority that controls every domain name. If you want to register a website like **example. Com**, you would have to contact this central body. As the number of websites and devices grows (millions of users, organizations, and services), this one body becomes overwhelmed by handling every request.\n\n- **Problem**: Slow response times and delays as a central system tries to manage names for everyone worldwide.\n- **Solution (Distributed)**: The system is divided into smaller parts. A central authority (like **ICANN**) only manages top-level domains like **. Com**, **. Org**, etc. Individual companies or organizations, such as **example. Com**, are then allowed to manage their own names (e.g., **mail. Example. Com**, **store. Example. Com**). This way, smaller, local authorities handle requests, speeding up the process.\n\n### 2. **Single Point of Failure Example**:\nSuppose there is a central server that manages all domain name resolutions (mapping names to IP addresses). If this server crashes, no one on the Internet would be able to access websites, because there would be no way to convert a domain name (like **google. Com**) into its IP address.\n\n- **Problem**: The entire Internet could stop functioning due to the failure of one system.\n- **Solution (Distributed)**: With a distributed DNS system, if one DNS server fails, others are still available to handle requests. For example, if a DNS server in **Europe** goes down, a server in **North America** can still resolve domain names like **google. Com** or **facebook. Com**.\n\n### Example of a **Hierarchical System**:\nIn a hierarchical name space, names are broken into parts:\n\n- **example. Com** is the domain name, where:\n  - **. Com** is managed by a central authority (ICANN).\n  - **example** is managed by the organization that registered it.\n  \nWithin **example. Com**, the company can have different subdomains:\n- **mail. Example. Com** (for email service)\n- **shop. Example. Com** (for their online store)\n\nEven if another organization has a subdomain named **shop**, like **shop. Apple. Com**, they don't conflict because the whole name is unique.\n\n### Summary:\n- **Centralized systems** are inefficient and risky for the massive scale of the Internet.\n- **Distributed, hierarchical systems** allow for better scalability, reliability, and prevent a single point of failure. They allow individual organizations to manage their own names while central authorities manage only the top-level domains.",
			"styleAttributes":{},
			"x":3120,
			"y":10140,
			"width":1240,
			"height":810,
			"color":"3"
		},
		{
			"id":"6a450685f2d559ae",
			"type":"text",
			"text":"### Name Space\n\n1. **Flat Name Space**:\n    \n    - **Definition**: A flat name space assigns names without any structure. Each name is a simple sequence of characters with no inherent meaning or organization.\n    - **Drawback**: This approach isn't suitable for large systems like the Internet, as it requires central control to avoid duplicate names, which would be inefficient and impractical at a global scale.\n2. **Hierarchical Name Space**:\n    \n    - **Definition**: In a hierarchical name space, names are structured and composed of multiple parts. Each part can represent different levels of organization, such as the nature of an organization, its name, departments, and specific hosts or resources.\n    - **Advantages**: This system allows decentralized management. A central authority can assign a base name (e.g., the organization name), while the organization itself manages the rest of the name. Even if different organizations use similar names at certain levels, the complete names remain unique.\n    - **Example**: If two organizations name a server \"caesar,\" the complete domain names might be `caesar.first.com` and `caesar.second.com`, ensuring they are distinguishable and unique.",
			"styleAttributes":{},
			"x":2060,
			"y":10164,
			"width":922,
			"height":381,
			"color":"3"
		},
		{
			"id":"45e66013b277599f",
			"type":"text",
			"text":"### Zones\n\n1. **Definition**:\n\t- Since the complete domain name hierarchy cannot be stored on a single server, it is divided among many servers. What a server is responsible for or has authority over is called a zone. We can define a zone as a contiguous part of the entire tree. \n    - A zone is a contiguous portion of the domain name space for which a DNS server is authoritative. The concept of a zone helps manage and distribute DNS data efficiently.\n    - If a server is responsible for a domain without subdividing it, the domain and zone are synonymous. However, if a server delegates authority for subdomains to other servers, the original server's zone refers to the domain it manages, while the subdomains have their own zones.\n2. **Zone Management**:\n    \n    - **Full Responsibility**: When a server is responsible for an entire domain without further delegation, it maintains a complete zone file that includes all information about nodes within that domain.\n    - **Partial Responsibility**: If a server delegates authority for subdomains, it keeps references to these lower-level servers while maintaining some level of authority over the higher-level domain. The detailed information about subdomains is stored in the respective lower-level servers.\n\n### Example Hierarchy\n\n- **Root Level**: The root server oversees the entire domain space.\n- **Top-Level Domains (TLDs)**: Such as `.com`, `.edu`, and `.org`. Each TLD has its own set of servers.\n- **Second-Level Domains**: Like `example.com`. These can be further divided into subdomains.\n- **Subdomains**: Further divisions within second-level domains, such as `mail.example.com` or `blog.example.com`.",
			"styleAttributes":{},
			"x":3437,
			"y":11680,
			"width":923,
			"height":560,
			"color":"4"
		},
		{
			"id":"663d7945e8580e33",
			"type":"file",
			"file":"source-images/Pasted image 20240901122811.png",
			"styleAttributes":{},
			"x":3437,
			"y":12320,
			"width":1206,
			"height":400
		},
		{
			"id":"c2d20574f0a925ea",
			"type":"text",
			"text":"I'd be happy to explain when zone and domain mean the same thing and when they differ, using examples to illustrate the concepts.\n\nWhen Zone and Domain Mean the Same Thing:\n\nA zone and a domain are the same when a server is responsible for the entire domain without delegating any parts of it to other servers.\n\nExample:\nLet's consider a small company \"example. Com\".\n\n1. If a single DNS server manages all records for example. Com and its subdomains (like mail. Example. Com, www.example.com), without delegating any part to other servers, then:\n   - The domain is: example. Com\n   - The zone is also: example. Com\n\nIn this case, the zone file on this server contains all the DNS records for example. Com and all its subdomains. The zone and domain boundaries are identical.\n\nWhen Zone and Domain Mean Different Things:\n\nZones and domains differ when a domain is split into multiple zones, with different servers responsible for different parts of the domain hierarchy.\n\nExample:\nLet's consider a larger organization \"bigcorp. Com\" with multiple departments.\n\n1. The main DNS server is responsible for bigcorp. Com, but delegates responsibility for subdomains to other servers:\n   - The domain is: bigcorp. Com\n   - The zone for the main server includes: bigcorp. Com, www.bigcorp.com, mail. Bigcorp. Com\n   - But it delegates hr. Bigcorp. Com and it. Bigcorp. Com to other servers\n\n2. For the HR department:\n   - The subdomain is: hr. Bigcorp. Com\n   - The zone for the HR DNS server is: hr. Bigcorp. Com (including all its own subdomains like payroll. Hr. Bigcorp. Com)\n\n3. For the IT department:\n   - The subdomain is: it. Bigcorp. Com\n   - The zone for the IT DNS server is: it. Bigcorp. Com (including all its own subdomains like helpdesk. It. Bigcorp. Com)\n\nIn this scenario:\n- The entire domain is still bigcorp. Com\n- But there are multiple zones: \n  1. A zone for bigcorp. Com (excluding hr and it subdomains)\n  2. A zone for hr. Bigcorp. Com\n  3. A zone for it. Bigcorp. Com\n\nEach zone is managed by a different DNS server, and each server is authoritative only for its specific zone, not the entire domain.\n\nThis division allows for distributed management of DNS records, which is crucial for large organizations or for the broader internet, where it would be impractical to have all DNS information for a top-level domain on a single server.",
			"styleAttributes":{},
			"x":4420,
			"y":11680,
			"width":760,
			"height":560,
			"color":"5"
		},
		{
			"id":"51bdd7a206320b54",
			"type":"file",
			"file":"source-images/Pasted image 20240901122840.png",
			"styleAttributes":{},
			"x":3437,
			"y":12800,
			"width":1206,
			"height":493
		},
		{
			"id":"6a6850e944b1b137",
			"type":"text",
			"text":"### Domain Name Space\n\nTo implement a hierarchical name space, the **domain name space** is designed as an **inverted-tree structure**:\n\n1. **Inverted-Tree Structure**:\n    \n    - **Root at the Top**: The hierarchy starts with a root node at the top. The tree can have up to 128 levels, ranging from level 0 (root) to level 127.\n    - **Labels**: Each node in the tree has a label, which is a string of up to 63 characters. The root label is an empty string (null string). DNS ensures that the children of a node (i.e., nodes branching from the same parent node) have different labels, guaranteeing unique domain names.\n2. **Domain Names**:\n    \n    - **Full Domain Name**: A domain name is a sequence of labels separated by dots. For example, in the domain name `aComputer.bDept.topUniversity.edu`, the labels are `aComputer`, `bDept`, `topUniversity`, and `edu`.\n    - **Fully Qualified Domain Name (FQDN)**: An FQDN ends with a null label (represented by a dot). It starts from a specific node and extends up to the root, covering the entire path.\n    - **Partially Qualified Domain Name (PQDN)**: A PQDN does not reach the root and is typically used within the same site. The missing part of the name (suffix) is provided by the resolver to convert it into an FQDN.\n3. **Domains**:\n    \n    - **Definition**: A domain represents a subtree of the domain name space. The domain name corresponds to the node at the top of the subtree. Domains can be further divided into subdomains, reflecting different levels of organization within the hierarchy.",
			"styleAttributes":{},
			"x":2138,
			"y":10590,
			"width":922,
			"height":360,
			"color":"3"
		},
		{
			"id":"ba65d3d00f4e0abb",
			"type":"text",
			"text":"### Hierarchy of Name Servers\n\n1. **Root Server**:\n    \n    - **Definition**: The root server is a crucial component of the DNS hierarchy. It oversees the entire domain name space but does not store detailed information about individual domains.\n    - **Function**: The root server's main role is to delegate authority to other servers. It maintains references to these servers, directing queries to the appropriate servers for further resolution.\n    - **Distribution**: There are several root servers distributed worldwide to ensure redundancy and reliability.\n2. **Primary and Secondary Servers**:\n    \n    - **Primary Server**:\n        - **Definition**: A primary server is responsible for storing the zone file, which contains detailed information about the domain and its subdomains for which it is authoritative.\n        - **Functions**: It creates, maintains, and updates the zone file. The primary server holds the authoritative data for its zone on its local disk.\n    - **Secondary Server**:\n        - **Definition**: A secondary server obtains its zone file from a primary or another secondary server. It does not create or update the zone file itself.\n        - **Functions**: It transfers and stores a copy of the zone file from the primary server or another secondary server. Updates to the zone file are managed by the primary server, and the secondary server receives the updated information periodically.\n        - **Purpose**: Secondary servers provide redundancy and load balancing. If a primary server fails, the secondary server can continue to serve DNS queries, ensuring uninterrupted access to the domain information.",
			"styleAttributes":{},
			"x":2138,
			"y":11680,
			"width":1222,
			"height":560,
			"color":"3"
		},
		{
			"id":"58d0c7e821bd2f1b",
			"type":"file",
			"file":"source-images/Pasted image 20240901123733.png",
			"styleAttributes":{},
			"x":4240,
			"y":13393,
			"width":960,
			"height":367
		},
		{
			"id":"5ddef9b739fa8e88",
			"type":"file",
			"file":"source-images/Pasted image 20240901121637.png",
			"styleAttributes":{},
			"x":2520,
			"y":11080,
			"width":917,
			"height":440
		},
		{
			"id":"a40b565e13099b27",
			"type":"text",
			"text":"**Recursive vs. Iterative**:\n\n- **Recursive**: The DNS server handles the entire resolution process and provides the final answer to the resolver.\n- **Iterative**: Each DNS server in the chain provides the next server’s address to the resolver, which must continue the resolution process until the final answer is obtained.",
			"styleAttributes":{},
			"x":3200,
			"y":13800,
			"width":893,
			"height":160,
			"color":"#ff0aeb"
		},
		{
			"id":"fabc026b12de2e84",
			"type":"text",
			"text":"### **Recursive Resolution**\n\n**Recursive Resolution Process**:\n\n1. **Initial Request**: An application on a host (e.g., `some.anet.com`) needs to find the IP address for `engineering.mcgraw-hill.com`. The local DNS resolver (client) sends a query to its local DNS server (e.g., `dns.anet.com`).\n    \n2. **Local DNS Server**: If the local DNS server doesn't know the address, it forwards the query to a root DNS server.\n    \n3. **Root DNS Server**: The root server, which does not have the IP address but knows the top-level domain (TLD) servers, directs the query to the TLD server responsible for `.com` domains.\n    \n4. **TLD DNS Server**: The TLD server doesn't have the address either but knows the DNS server for the McGraw-Hill domain (e.g., `dns.mcgraw-hill.com`). It forwards the query to this server.\n    \n5. **Domain-Specific DNS Server**: The McGraw-Hill DNS server knows the IP address for `engineering.mcgraw-hill.com` and returns it to the TLD server.\n    \n6. **Propagation Back**: The TLD server sends the IP address back to the root server, which sends it to the local DNS server, which then provides it to the original resolver. The local DNS server caches this address for future queries.",
			"styleAttributes":{},
			"x":3180,
			"y":13400,
			"width":893,
			"height":360,
			"color":"4"
		},
		{
			"id":"4fa0a4df363e13be",
			"type":"text",
			"text":"### **Iterative Resolution**\n\n**Iterative Resolution Process**:\n\n1. **Initial Request**: Similar to recursive resolution, the resolver sends a query to the local DNS server.\n    \n2. **Response from Local Server**: If the local server does not know the IP address, it sends the IP address of the root DNS server back to the resolver.\n    \n3. **Root Server**: The resolver then queries the root server, which returns the address of the TLD server.\n    \n4. **TLD Server**: The resolver queries the TLD server, which returns the address of the domain-specific DNS server.\n    \n5. **Domain Server**: The resolver queries the McGraw-Hill DNS server, which provides the IP address for `engineering.mcgraw-hill.com`.\n    \n6. **Final Response**: The resolver receives the IP address and passes it back to the original application.",
			"styleAttributes":{},
			"x":3200,
			"y":14040,
			"width":893,
			"height":340,
			"color":"4"
		},
		{
			"id":"8156b6e7aacdfc5b",
			"type":"file",
			"file":"source-images/Pasted image 20240901123803.png",
			"styleAttributes":{},
			"x":4240,
			"y":13960,
			"width":1000,
			"height":474
		},
		{
			"id":"e38d5692cb80970a",
			"type":"text",
			"text":"### **Caching**\n\n**Caching Mechanism**:\n\n- **Purpose**: Reduces resolution time by storing previously retrieved address mappings in memory.\n- **Mechanism**: When a DNS server retrieves a mapping, it caches the result. Subsequent queries for the same address can be resolved directly from the cache.\n- **Unauthoritative Responses**: Cached responses are marked as unauthoritative to indicate that they are not from the original source but are instead derived from a cache.\n- **Time to Live (TTL)**: Each cached mapping has a TTL value, specifying how long the mapping is valid. Once the TTL expires, the mapping is purged from the cache, and new queries must be resolved again through the DNS hierarchy.\n\n**TTL and Cache Purging**:\n\n- **TTL**: This value is set by the authoritative DNS server and dictates the duration a DNS server should cache the mapping.\n- **Cache Management**: DNS servers periodically check their cache and remove entries that have expired based on TTL, ensuring that outdated information does not persist.",
			"styleAttributes":{},
			"x":3200,
			"y":14480,
			"width":893,
			"height":440,
			"color":"4"
		},
		{
			"id":"ad7e2a06eb48e1b8",
			"type":"text",
			"text":"**Name-Address Resolution Overview**\n\n**Name-Address Resolution**: Name-address resolution refers to the process of mapping domain names to IP addresses and vice versa. This process is fundamental to the functioning of the internet and is managed by the Domain Name System (DNS), a client-server application. The resolver, a DNS client, requests the address information from DNS servers, which can either provide the answer directly, refer to other servers, or request other servers to handle the query.",
			"styleAttributes":{},
			"x":2240,
			"y":13400,
			"width":760,
			"height":280,
			"color":"3"
		},
		{
			"id":"f559e0925c8e254f",
			"type":"text",
			"text":"**Resource Records in DNS**\n\n**Resource Records (RRs)**:\nA resource record (RR) is the fundamental data structure in the Domain Name System (DNS) and contains the following fields:\n1. **Domain Name**: Specifies the domain to which the record pertains.\n2. **Type**: Indicates the type of data stored in the record.\n3. **Class**: Specifies the network class, with \"IN\" (Internet) being the most common.\n4. **TTL (Time to Live)**: Defines how long the record should be cached by DNS servers.\n5. **Value**: Contains the actual data associated with the domain name.\n\n**Common Types of Resource Records**:\n\n| **Type** | **Interpretation of Value** |\n|----------|------------------------------|\n| **A**    | A 32-bit IPv 4 address        |\n| **NS**   | Identifies authoritative servers for a domain |\n| **CNAME**| Defines an alias for the domain name |\n| **SOA**  | Marks the beginning of a zone |\n| **MX**   | Redirects mail to a mail server |\n| **AAAA** | A 128-bit IPv 6 address       |\n\n**DNS Messages**:\nDNS messages come in two types: queries and responses. Both share a common format.\n\n**DNS Message Format**:\n1. **Header**:\n   - **Identification**: Matches responses with queries.\n   - **Flags**: Indicates if the message is a query or response, and its status (e.g., error codes).\n   - **Number of Records**: Counts of question, answer, authoritative, and additional records.\n\n2. **Sections**:\n   - **Question Section**: Contains one or more question records, present in both queries and responses.\n   - **Answer Section**: Contains one or more resource records with the requested data, present only in responses.\n   - **Authoritative Section**: Provides information about authoritative servers for the queried domain.\n   - **Additional Section**: Provides supplementary information that might assist in resolving the query.\n\n**Example**:\nUsing `nslookup` to retrieve the IP address for `www.forouzan.biz`:\n```\n$ nslookup www.forouzan.biz\nName: www.forouzan.biz\nAddress: 198.170.240.179\n```\n\n**Encapsulation**:\n- **UDP (User Datagram Protocol)**: Used for DNS queries and responses less than 512 bytes in size. It is efficient but does not guarantee delivery.\n- **TCP (Transmission Control Protocol)**: Used when responses exceed 512 bytes or for zone transfers. It provides reliable communication.\n\n**DNS Operation with UDP and TCP**:\n1. **UDP Usage**: Resolver uses UDP if it expects a response within the 512-byte limit.\n2. **TCP Usage**: If a response exceeds 512 bytes, or if the resolver knows beforehand, TCP is used. For large responses or zone transfers, TCP is preferred.\n\n**Registrars**:\n- **Domain Registration**: New domains are added to the DNS through registrars accredited by ICANN. Registrars verify domain name uniqueness and enter it into the DNS database.\n- **Registration Example**: A new domain registration might include information such as the domain name and server IP address:\n  ```\n  Domain name: ws.wonderful.com\n  IP address: 200.200.200.5\n  ```\n\n**Dynamic DNS (DDNS)**:\n- **Purpose**: Automates updates to DNS records for frequent changes (e.g., adding/removing hosts or changing IP addresses).\n- **Mechanism**: Updates are sent to the primary DNS server, which then notifies secondary servers. Updates can be active (primary server sends notifications) or passive (secondary servers periodically check for changes).\n\n**Security of DNS**:\nDNS is critical for internet operations but is vulnerable to various attacks:\n1. **Information Leakage**: Attackers might read DNS responses to infer user behavior. Confidentiality measures are needed.\n2. **Spoofing**: Attackers can intercept and alter DNS responses to redirect users. Message origin authentication and integrity checks help prevent this.\n3. **Denial-of-Service (DoS) Attacks**: Flooding a DNS server to overwhelm it can disrupt services. DNSSEC helps, but additional protection is necessary.\n\n**DNSSEC (Domain Name System Security Extensions)**:\n- **Purpose**: Provides message origin authentication and integrity through digital signatures.\n- **Limitations**: Does not offer message confidentiality or specific protection against DoS attacks. Caching systems provide some defense against these attacks.\n\nUnderstanding and implementing these DNS mechanisms, types, and security measures are essential for maintaining efficient and secure domain name resolution.",
			"styleAttributes":{},
			"x":2040,
			"y":15080,
			"width":1200,
			"height":480,
			"color":"3"
		},
		{
			"id":"ae0dec9c42fdeedd",
			"type":"text",
			"text":"### Socket Addresses\n\nFor two-way communication between a client and a server, a pair of addresses is required: one for the local (sender) and one for the remote (receiver). In the context of socket communication, this means that each endpoint must have a socket address, which is a combination of an IP address and a port number.\n\n- **Local Socket Address (Server):** The server's local socket address is typically provided by the operating system, which knows the computer's IP address. The port number can either be a standard one (e.g., port 80 for HTTP) or assigned by the server's designer if it is a non-standard process.\n    \n- **Remote Socket Address (Server):** The remote socket address for the server is determined when a client initiates communication. The server learns the client's socket address from the incoming request, allowing it to send responses to the correct destination.\n    \n- **Local Socket Address (Client):** The client’s local socket address is also provided by the operating system. The port number assigned to the client is temporary (ephemeral) and must be unique.\n    \n- **Remote Socket Address (Client):** The client must know the server's socket address to initiate communication. This may involve knowing the server's IP address and port number directly or resolving the server's name (e.g., through DNS) to find the corresponding IP address.",
			"styleAttributes":{},
			"x":1501,
			"y":170,
			"width":520,
			"height":510,
			"color":"3"
		},
		{
			"id":"6e112a4720a1ccca",
			"type":"text",
			"text":"**Simplified Comparison of TCP and UDP:**\n\n| **Basis**          | **Transmission Control Protocol (TCP)**                      | **User Datagram Protocol (UDP)**                        |\n|--------------------|-------------------------------------------------------------|--------------------------------------------------------|\n| **Type of Service** | Connection-oriented (needs connection before data transfer)  | Datagram-oriented (no connection setup required)        |\n| **Reliability**     | Reliable, ensures data reaches the destination               | Not reliable, delivery of data is not guaranteed        |\n| **Error Checking**  | Extensive error checking with flow control and acknowledgments | Basic error checking using checksums                    |\n| **Acknowledgment**  | Sends acknowledgment for data received                      | No acknowledgment mechanism                            |\n| **Sequence**        | Ensures data arrives in the correct order                    | No sequencing, handled by the application if needed     |\n| **Speed**           | Slower than UDP                                              | Faster, simpler, and more efficient                     |\n| **Retransmission**  | Retransmits lost packets                                     | No retransmission of lost packets                       |\n| **Header Length**   | 20-60 bytes (variable length)                                | 8 bytes (fixed length)                                  |\n| **Weight**          | Heavy-weight protocol                                        | Lightweight protocol                                    |\n| **Handshaking**     | Uses handshaking (SYN, ACK)                                  | No handshaking (connectionless)                         |\n| **Broadcasting**    | Does not support broadcasting                               | Supports broadcasting                                  |\n| **Protocols**       | Used by HTTP, HTTPS, FTP, SMTP, Telnet                       | Used by DNS, DHCP, TFTP, SNMP, RIP, VoIP                |\n| **Stream Type**     | Byte stream                                                 | Message stream                                         |\n| **Overhead**        | Higher overhead than UDP                                    | Very low overhead                                      |\n| **Applications**    | Used where reliable communication is critical (e.g., email, web) | Used where speed is more important than reliability (e.g., VoIP, streaming) |\n\nThis table highlights the key differences between TCP and UDP based on their features and use cases.",
			"styleAttributes":{},
			"x":2991,
			"y":160,
			"width":940,
			"height":720
		},
		{
			"id":"64949953cf8e0a8a",
			"type":"text",
			"text":"### Socket\na socket is supposed to behave like a terminal or a file, it is not a physical entity like them; it is an abstraction. It is a data structure that is created and used by the application program.",
			"styleAttributes":{},
			"x":1501,
			"y":759,
			"width":520,
			"height":200,
			"color":"3"
		},
		{
			"id":"f79eb2570927b718",
			"type":"file",
			"file":"source-images/Pasted image 20240901033228.png",
			"styleAttributes":{},
			"x":2101,
			"y":196,
			"width":637,
			"height":563
		},
		{
			"id":"56ba9c409828ba36",
			"type":"file",
			"file":"source-images/Pasted image 20240901033647.png",
			"styleAttributes":{},
			"x":2101,
			"y":824,
			"width":637,
			"height":151
		},
		{
			"id":"df2ee1f68c864ab8",
			"type":"text",
			"text":"### Web Client (Browser)\n\nA variety of vendors offer commercial browsers that interpret and display web pages. Despite differences among them, all browsers share a common architecture consisting of three main components: the controller, client protocols, and interpreters (see Figure 2.9).\n\n- **Controller:** The controller is responsible for receiving input from the keyboard or mouse and utilizing client programs to access the document. Once the document is accessed, the controller uses interpreters to render the document on the screen.\n    \n- **Client Protocols:** The client protocol is responsible for the communication between the client and server. Common protocols include HTTP (HyperText Transfer Protocol), FTP (File Transfer Protocol), SSH (Secure Shell), and SMTP (Simple Mail Transfer Protocol).\n    \n- **Interpreters:** Interpreters process and display different types of documents. For example, HTML interpreters render web pages, while Java and JavaScript interpreters handle scripts and interactive content.\n    \n\nPopular web browsers include Internet Explorer, Netscape Navigator, and Firefox.",
			"styleAttributes":{},
			"x":2282,
			"y":2450,
			"width":858,
			"height":470,
			"color":"2"
		},
		{
			"id":"97091f9c0dd76cf5",
			"type":"text",
			"text":"### UDP (User Datagram Protocol)\n\n**Connectionless Service:**  \nUDP is a connectionless protocol, meaning that no logical connection is established between the communicating processes. Each message is treated as an independent entity, encapsulated in a packet known as a datagram. The protocol does not recognize any relationship between consecutive datagrams, even if they originate from the same source and are destined for the same destination.\n\n**Unreliable Service:**  \nUDP is considered an unreliable protocol because it does not guarantee the delivery of messages. While it may check for data corruption during transmission, it does not request the sender to resend lost or corrupted datagrams. This simplicity can be advantageous in situations where speed is more important than reliability.\n\n**Message-Oriented:**  \nUnlike TCP, UDP preserves the boundaries of messages, treating each datagram as a distinct unit. This feature makes UDP suitable for applications that send small, discrete messages where maintaining message integrity is important.\n\n**Use Cases:**  \nUDP is typically used in applications where simplicity and speed are prioritized over reliability. Examples include certain multimedia applications, network management tasks, and situations where small messages are exchanged.",
			"styleAttributes":{},
			"x":1822,
			"y":1194,
			"width":698,
			"height":286,
			"color":"3"
		},
		{
			"id":"8b6e5f5d730e7580",
			"type":"text",
			"text":"### TCP (Transmission Control Protocol)\n\n**Connection-Oriented Service:**  \nTCP provides a connection-oriented service, requiring the two communicating processes to establish a logical connection before data transfer begins. This connection is established through a process known as handshaking, where parameters such as data packet size and buffer size are agreed upon.\n\n**Reliable Service:**  \nTCP ensures the reliable transmission of data by numbering the bytes in the stream and retransmitting any lost or corrupted data. This makes TCP a reliable protocol, as the receiver can request the sender to resend any missing or damaged bytes. Additionally, TCP offers flow control and congestion control to optimize data transfer.\n\n**Byte-Stream Oriented:**  \nUnlike UDP, TCP does not preserve message boundaries. Instead, it treats the data as a continuous stream of bytes, which may be divided into multiple segments during transmission. This characteristic makes TCP suitable for applications that require the reliable transfer of large amounts of data.\n\n**Use Cases:**  \nTCP is commonly used in applications that require reliable, long-term communication, such as file transfers, web browsing, and email services. Its ability to ensure data integrity and manage flow control makes it ideal for these use cases.",
			"styleAttributes":{},
			"x":1822,
			"y":1520,
			"width":698,
			"height":260,
			"color":"3"
		},
		{
			"id":"1ef81849edbbde06",
			"type":"text",
			"text":"### SCTP (Stream Control Transmission Protocol)\n\n**Combination of UDP and TCP:**  \nSCTP offers a hybrid service that combines the features of both UDP and TCP. Like TCP, SCTP provides a connection-oriented and reliable service. However, it is also message-oriented like UDP, allowing it to preserve message boundaries while ensuring reliable data transfer.\n\n**Multi-Stream Service:**  \nOne of SCTP's unique features is its ability to support multiple network-layer connections. This allows the application to maintain communication even if one of the connections fails, providing greater resilience in unreliable network environments.\n\n**Use Cases:**  \nSCTP is suitable for applications that require both reliability and resilience to network-layer failures. It is often used in telecommunications signaling, where maintaining a stable connection despite network issues is crucial.\n\nIn conclusion, the choice between UDP, TCP, and SCTP depends on the specific requirements of the application, such as the need for speed, reliability, or a balance of both.",
			"styleAttributes":{},
			"x":1822,
			"y":1800,
			"width":718,
			"height":280,
			"color":"3"
		},
		{
			"id":"eb82233a9b0830d1",
			"type":"file",
			"file":"source-images/Pasted image 20240901041659.png",
			"styleAttributes":{},
			"x":1460,
			"y":2140,
			"width":645,
			"height":209
		},
		{
			"id":"4e886663467051f9",
			"type":"text",
			"text":"**World Wide Web**\n\nThe concept of the World Wide Web (WWW or Web) was first proposed by Tim Berners-Lee in 1989 at CERN (the European Organization for Nuclear Research). The initial aim was to enable researchers across Europe to access each other's research. The commercial Web began to take shape in the early 1990s.\n\nToday, the Web serves as a vast repository of information, where documents—known as web pages—are distributed globally and interlinked. This distribution model prevents the overload of any single server, as each web server can contribute new web pages to the repository. The ability to link web pages together enhances the Web's functionality; hyperlinks allow users to access related documents stored on different servers worldwide. This concept of hypertext, which predates the Internet, allows documents to retrieve linked content automatically. The term \"hypertext\" has evolved into \"hypermedia\" to encompass various types of content such as text, images, audio, and video.\n\n**Architecture**\n\nThe Web operates as a distributed client-server system. A client (using a browser) accesses services provided by servers, with the service being distributed across multiple locations or sites. Each site hosts web pages, which can include links to other web pages within the same or different sites. Web pages can be categorized as simple (without links) or composite (with links). Each page has a unique file name and address.\n\n**Example 2.2**  \nConsider the need to retrieve a scientific document that references another text file and a large image. The main document and the image are stored as separate files on the same site, while the referenced text file is hosted on another site. To view the entire content, three transactions are required:\n\n1. The first transaction retrieves the main document (file A), which includes references to the other files.\n2. The second transaction fetches the image (file B) when a user clicks on its reference within the main document.\n3. The third transaction retrieves the referenced text file (file C) when clicked.\n\nEach file—A, B, and C—is an independent web page with its own address. Although file A contains references to files B and C, these files can be accessed individually. For instance, one user might retrieve file B in one transaction, while another user retrieves file C in a separate transaction.",
			"styleAttributes":{},
			"x":480,
			"y":2420,
			"width":820,
			"height":800,
			"color":"6"
		},
		{
			"id":"21f06613b3c5aab6",
			"type":"text",
			"text":"1. Well-known ports: 0-1023\n2. Registered ports: 1024-49151\n3. Dynamic/Private ports: 49152-65535",
			"styleAttributes":{},
			"x":592,
			"y":3280,
			"width":644,
			"height":120,
			"color":"#c256b9"
		},
		{
			"id":"96950085aa8d4fa1",
			"type":"file",
			"file":"Source Materials/Pasted image 20240909100416.png",
			"styleAttributes":{},
			"x":3188,
			"y":2450,
			"width":952,
			"height":560
		},
		{
			"id":"1d4c252ade05e56c",
			"type":"text",
			"text":"### Web Server\n\nA web server stores web pages and responds to client requests by sending the requested documents. To enhance efficiency, servers often use caching to store frequently accessed files in memory, which is faster than retrieving them from disk. Additionally, servers may employ multithreading or multiprocessing to handle multiple requests simultaneously.\n\nNotable web servers include Apache and Microsoft Internet Information Server.",
			"styleAttributes":{},
			"x":2225,
			"y":3040,
			"width":935,
			"height":280,
			"color":"2"
		},
		{
			"id":"b20620d0f93726d3",
			"type":"text",
			"text":"### Uniform Resource Locator (URL)\n\nA URL uniquely identifies a web page and consists of four main components:\n\n1. **Protocol:** Indicates the client-server application to be used. The most common protocol is HTTP, but others like FTP are also used.\n    \n2. **Host:** Specifies the server's address. This can be an IP address (e.g., 64.23.56.17) or a domain name (e.g., forouzan.com).\n    \n3. **Port:** A 16-bit integer that designates the server port. HTTP typically uses port 80, but other ports can be specified if necessary.\n    \n4. **Path:** Defines the file's location and name on the server. The path format varies by operating system. For example, in UNIX, it might look like `/top/next/last/myfile`.\n    \n\nThe URL format combines these components using different separators:\n\n- `protocol://host/path` (most commonly used)\n- `protocol://host:port/path` (used when specifying a port number)\n\n**Example 2.3**  \nThe URL `http://www.mhhe.com/compsci/forouzan/` specifies a web page related to one of the authors of this book. The `www.mhhe.com` part is the host, and `compsci/forouzan/` is the path leading to the specific page.",
			"styleAttributes":{},
			"x":4320,
			"y":2775,
			"width":1125,
			"height":470,
			"color":"3"
		},
		{
			"id":"f98219b8452c2560",
			"type":"text",
			"text":"### Web Documents\n\nWeb documents fall into three broad categories:\n\n1. **Static Documents:** These are fixed-content documents created and stored on a server. Users can retrieve but not modify the contents. Static documents are commonly written in HTML, XML, XSL, or XHTML.\n    \n2. **Dynamic Documents:** These are generated by a web server in response to a request. The server runs an application or script to create the document, and the contents can vary with each request. Examples include time and date retrieval or database-driven content. Technologies for creating dynamic documents include Common Gateway Interface (CGI), Java Server Pages (JSP), Active Server Pages (ASP), and ColdFusion.\n    \n3. **Active Documents:** Not explicitly covered in the provided text, but typically refer to documents that contain embedded scripts or interactive content, such as Java applets or Flash.",
			"styleAttributes":{},
			"x":4310,
			"y":3320,
			"width":1145,
			"height":320,
			"color":"3"
		},
		{
			"id":"b0e817d4ea494602",
			"type":"text",
			"text":"**Nonpersistent Connections**\n\n- **Description:** In nonpersistent connections, each request/response pair uses a separate TCP connection.\n- **Steps:**\n    1. The client opens a TCP connection and sends a request.\n    2. The server responds and then closes the connection.\n    3. The client reads the data until an end-of-file marker is encountered, then closes the connection.\n- **Overhead:** This method incurs high overhead because each file request (e.g., an HTML page with multiple linked images) requires opening and closing separate connections. For each connection, there are multiple handshakes (e.g., connection establishment and termination), which adds latency and requires resources on both the client and server.\n- **Example 2.4:** If a client needs to access a web page with one image, it will need to establish and close two TCP connections—one for the HTML page and another for the image. This involves multiple handshake messages for connection setup and teardown, increasing overhead and resource usage.",
			"styleAttributes":{
				"shape":null
			},
			"x":3280,
			"y":3700,
			"width":1302,
			"height":300,
			"color":"3"
		},
		{
			"id":"ca0de5302082499c",
			"type":"text",
			"text":"1. **Persistent Connections**\n    \n    - **Description:** HTTP/1.1 introduces persistent connections by default. In this approach, the server keeps the TCP connection open for multiple requests/responses, allowing for more efficient communication.\n    - **Behavior:**\n        - After sending a response, the server can keep the connection open for additional requests from the same client.\n        - The server may close the connection if requested by the client or if a timeout period is reached.\n        - If the length of the data is not known (e.g., for dynamically generated content), the server may send the data without specifying length and close the connection after transmission.\n    - **Benefits:** Persistent connections save time and resources:\n        - **Reduced Overhead:** Only one set of buffers and variables is needed for each persistent connection, as opposed to multiple sets for nonpersistent connections.\n        - **Faster Transactions:** The time spent establishing and terminating connections is minimized, improving overall efficiency.",
			"styleAttributes":{},
			"x":3280,
			"y":4020,
			"width":1302,
			"height":300,
			"color":"3"
		},
		{
			"id":"eb9abd1262fd3d8c",
			"type":"file",
			"file":"Source Materials/Pasted image 20240909100527.png",
			"styleAttributes":{},
			"x":2225,
			"y":3375,
			"width":963,
			"height":505
		},
		{
			"id":"d19e3d3dcd8a345c",
			"type":"file",
			"file":"Source Materials/Pasted image 20240909100629.png",
			"styleAttributes":{},
			"x":4720,
			"y":3937,
			"width":1232,
			"height":1117
		},
		{
			"id":"141e625fbb7fd024",
			"type":"text",
			"text":"## Cookies\nCookies are small pieces of data that websites use to remember information about users as they browse the web. Originally, the web was designed to be \"stateless,\" meaning that after a client (e.g., a browser) makes a request and a server responds, their interaction ends. However, as the web evolved, the need arose to remember information about users across multiple interactions. This led to the development of cookies.\n\n### How Cookies Work:\n\n1. **Creation and Storage**: When a server receives a request from a client, it can store information about that client, such as their domain name, the contents of the cookie (e.g., user ID, preferences, etc.), and a timestamp. This information is sent to the client in the server's response.\n2. **Client-Side Storage**: The browser stores this cookie in a directory, organized by the server's domain name.\n3. **Using Cookies**: When the client makes a new request to the server, the browser checks for any stored cookies from that server. If found, the cookie is included in the request, allowing the server to recognize the returning client.\n\n### Use Cases of Cookies:\n\n1. **E-commerce**: Online stores use cookies to manage shopping carts. When a user selects an item, a cookie is updated with the cart's contents. Upon checkout, the server retrieves the cookie to calculate the total charge.\n2. **Access Control**: Websites that restrict access to registered users can use cookies to identify returning registered users without requiring them to log in again.\n3. **Web Portals**: Cookies store user preferences, such as selected web pages or settings, which are retrieved when the user revisits the site.\n4. **Advertising**: Cookies are used by advertising agencies to track user behavior across multiple websites. This information helps create user profiles that can be sold to other parties, although this practice has raised privacy concerns.\n\n### Example of Cookies in E-commerce:\n\nIn a scenario involving an online store (e.g., BestToys), the server creates a shopping cart for a shopper and assigns it an ID (e.g., 12343). This ID is sent to the client in a cookie. When the client selects items, the cookie is included in subsequent requests. The server uses the cookie ID to update the shopping cart and process the order. If the shopper returns later, the server can retrieve all stored information using the cookie.",
			"styleAttributes":{},
			"x":3257,
			"y":5220,
			"width":1425,
			"height":720,
			"color":"3"
		},
		{
			"id":"e544be4853118a81",
			"type":"text",
			"text":"### Application Programming Interface (API) in Client-Server Communication\n\nIn a client-server architecture, a key question is how the client process communicates with the server process. While a computer program typically operates using a predefined set of instructions in a programming language, communicating with another process requires specialized instructions. This new set of instructions allows the lower four layers of the TCP/IP protocol suite to handle connection management, data transfer, and connection termination. Such a set of instructions is known as an Application Programming Interface (API).\n\nAn API serves as a bridge between the application layer and the operating system, enabling processes to interact with the underlying TCP/IP protocol. This interaction allows communication through the Internet by sending and receiving messages. Various APIs have been developed for this purpose, with three common ones being the socket interface, Transport Layer Interface (TLI), and STREAM. Among these, the socket interface is the most widely used and serves as a general method for network communication at the application layer.\n\nThe socket interface was developed in the early 1980s at UC Berkeley as part of the UNIX environment. It provides a standardized set of instructions for communication between the application layer and the operating system. The socket interface allows processes to treat network communication similarly to other I/O operations, such as reading from a keyboard or writing to a file.\n\nIn essence, a socket is an abstraction rather than a physical entity, functioning as a data structure created and utilized by the application program. Communication between a client process and a server process is conceptualized as communication between two sockets, one at each end of the connection. The client views the socket as the entity that sends the request and receives the response, while the server sees it as the entity that receives the request and provides the response.",
			"styleAttributes":{},
			"x":576,
			"y":248,
			"width":704,
			"height":792,
			"color":"2"
		},
		{
			"id":"6c223e55f2c1f661",
			"type":"text",
			"text":"### Client-Server Paradigm\n\nIn the client-server paradigm, communication at the application layer occurs between two running application programs, known as processes: the client and the server. The client is the program that initiates the communication by sending a request to the server. The server, in turn, is an application program that waits for incoming requests from clients. Upon receiving a request, the server processes it, prepares a response, and sends the result back to the client.\n\nA critical aspect of this paradigm is that the server must be running and ready to accept requests at any time, while the client only needs to be active when it requires a service. This means that if two computers are connected, the server program should be started and continuously run on one of them, awaiting client requests. On the other hand, the client program is started only when the service is needed, sends a limited number of requests, receives responses, and then terminates.\n\nIn summary, the server's lifetime is typically infinite, as it must be continuously available to handle client requests, whereas the client's lifetime is finite, as it operates only when it needs to interact with the server.",
			"styleAttributes":{
				"border":null,
				"shape":null
			},
			"x":-160,
			"y":360,
			"width":560,
			"height":220,
			"color":"1"
		},
		{
			"id":"84d69d572d0bcf1e",
			"type":"text",
			"text":"### Using Services of the Transport Layer\n\n**Introduction to Transport Layer Services:**  \nA pair of processes on the Internet, whether used by humans or programs, provide services to users. However, these processes require the transport layer's services for communication since there is no direct physical communication at the application layer. In the TCP/IP suite, three common transport layer protocols are utilized: UDP, TCP, and SCTP. When developing new applications, selecting the appropriate transport layer protocol is crucial, as it significantly impacts the application's functionality. Understanding the services provided by each protocol helps in making informed decisions about which one to use.",
			"styleAttributes":{},
			"x":576,
			"y":1081,
			"width":805,
			"height":279,
			"color":"2"
		},
		{
			"id":"5bd9d68658434faa",
			"type":"text",
			"text":"### HyperText Transfer Protocol (HTTP)\n\nThe HyperText Transfer Protocol (HTTP) is crucial for retrieving web pages and managing client-server communication on the web. Here’s a breakdown of how it works:\n\n#### Basic Operation\n\n- **Client-Server Interaction:** An HTTP client (such as a web browser) sends a request to an HTTP server, which then returns a response.\n- **Port Number:** HTTP servers typically use port 80, while clients use temporary port numbers.\n- **TCP Utilization:** HTTP relies on TCP (Transmission Control Protocol) for reliable, connection-oriented communication. TCP ensures that messages are delivered accurately and in order, handling retransmissions and error correction as needed.",
			"styleAttributes":{},
			"x":2282,
			"y":4050,
			"width":678,
			"height":380,
			"color":"2"
		},
		{
			"id":"f21b53ba448c71f3",
			"type":"text",
			"text":"## HTTP Message Formats\n\nHTTP defines specific formats for request and response messages to facilitate communication between clients and servers. Both types of messages are structured similarly but serve different purposes. Here’s a detailed overview:\n\n#### General Message Structure\n\nEach HTTP message consists of four sections:\n1. **Request Line** (for requests) / **Status Line** (for responses)\n2. **Header Lines**\n3. **Blank Line**\n4. **Body** (optional for both requests and responses)\n\n**Request Message Format**\n- **Request Line:** This is the first line of the request message and includes:\n  - **Method:** The HTTP method (e.g., GET, POST, PUT) that indicates the desired action.\n  - **URL:** The Uniform Resource Locator specifying the resource to be accessed.\n  - **Version:** The HTTP version being used (e.g., HTTP/1.1).\n\n  Example of a request line: `GET /index.html HTTP/1.1`\n\n- **Header Lines:** These lines provide additional information to the server. Each header line contains:\n  - **Header Name:** The name of the header (e.g., `User-Agent`, `Accept`).\n  - **Header Value:** The value associated with the header name.\n\n  Example header lines:\n  ```\n  Accept: text/html\n  User-Agent: Mozilla/5.0\n  ```\n\n- **Body:** The body of the request can contain data being sent to the server, such as form data or file uploads. It is present only for methods like POST and PUT.\n\n  Example request with body (POST):\n  ```\n  POST /submit-form HTTP/1.1\n  Content-Type: application/x-www-form-urlencoded\n  Content-Length: 29\n\n  name=John+Doe&age=30\n  ```\n\n**Response Message Format**\n- **Status Line:** This is the first line of the response message and includes:\n  - **Version:** The HTTP version (e.g., HTTP/1.1).\n  - **Status Code:** A three-digit code indicating the result of the request (e.g., 200 for success, 404 for not found).\n  - **Status Phrase:** A brief description of the status code.\n\n  Example of a status line: `HTTP/1.1 200 OK`\n\n- **Header Lines:** These lines provide additional information from the server to the client. Each header line follows the same format as in the request message.\n\n  Example header lines:\n  ```\n  Content-Type: text/html\n  Content-Length: 1234\n  ```\n\n- **Body:** The body contains the actual content of the response, such as the HTML of a web page, an image, or other data. The body is omitted in responses where the status code indicates an error or if the response is purely informational.\n\n  Example response body:\n  ```\n  <html>\n  <body>\n    <h1>Hello, world!</h1>\n  </body>\n  </html>\n  ```\n\n#### Common HTTP Methods\n\n- **GET:** Requests a document from the server. No body in the request.\n- **HEAD:** Requests only the headers of a document, useful for checking if a document has been modified.\n- **PUT:** Uploads a document to the server. The body contains the document.\n- **POST:** Sends data to the server, which may modify or add to existing resources. The body contains the data.\n- **TRACE:** Echos the request back to the client, useful for debugging.\n- **DELETE:** Requests the removal of a resource on the server.\n- **CONNECT:** Reserved for future use or used by proxy servers.\n- **OPTIONS:** Requests information about the options available for a resource or server.\n\n#### Example Messages\n\n- **Example 2.6:** Retrieving an image\n  ```\n  GET /usr/bin/image1 HTTP/1.1\n  Accept: image/gif\n  Accept: image/jpeg\n\n  HTTP/1.1 200 OK\n  Date: Mon, 10-Jan-2011 13:15:14 GMT\n  Server: Challenger\n  Content-Encoding: MIME-version 1.0\n  Content-Length: 2048\n\n  [Body of the image]\n  ```\n\n- **Example 2.7:** Posting a new document\n  ```\n  PUT /new-page HTTP/1.1\n  Content-Type: text/html\n  Content-Length: 1234\n\n  [Body of the new document]\n  \n  HTTP/1.1 201 Created\n  Date: Mon, 10-Jan-2011 13:15:14 GMT\n  Server: Challenger\n  Content-Type: text/html\n  Content-Length: 2345\n\n  [Body of the created document]\n  ```\n\n#### Conditional Requests\n\nClients can include conditions in their requests using headers like `If-Modified-Since` to retrieve content only if it has been modified since a specified date.\n\n**Example 2.8:** Conditional request based on modification date\n  ```\n  GET /page.html HTTP/1.1\n  If-Modified-Since: Mon, 01-Jan-2024 00:00:00 GMT\n\n  HTTP/1.1 304 Not Modified\n  Date: Mon, 10-Jan-2011 13:15:14 GMT\n  ```\n\nIn this case, the server indicates that the document has not been modified since the specified date, and therefore does not include a body in the response.",
			"styleAttributes":{},
			"x":3257,
			"y":4380,
			"width":1425,
			"height":785,
			"color":"3"
		},
		{
			"id":"6583d437f488c9ec",
			"type":"text",
			"text":"## Web Caching: Proxy Server\n\nA **proxy server** is an intermediary server that caches (stores) copies of responses to recent requests. When a client (such as a web browser) sends a request, it first goes to the proxy server. The proxy server checks if it has a cached copy of the requested resource. If it does, it directly sends the response to the client. If not, it forwards the request to the original target server, caches the response when it arrives, and then sends it to the client.\n\n#### Benefits of Using a Proxy Server:\n\n- **Reduces Load on the Original Server**: By serving cached responses, the proxy server decreases the number of requests the original server has to handle.\n- **Decreases Network Traffic**: Cached responses reduce the amount of data that needs to be sent over the network.\n- **Improves Latency**: Serving cached responses is faster than fetching them from the original server, reducing the time it takes for the client to receive the data.\n\n#### Proxy Server Functions:\n\n- **Acts as Both Client and Server**: When a proxy server receives a request and has a cached response, it acts as a server by sending the response to the client. When it does not have a cached response, it acts as a client by sending the request to the target server.\n\n#### Proxy Server Locations:\n\nProxy servers are typically located closer to the client side, and they can be arranged in a hierarchy:\n\n1. **Client-Side Proxy**: A proxy can be installed on a client computer to store frequently accessed resources.\n2. **LAN Proxy**: In a company, a proxy server might be installed within the local area network (LAN) to reduce external data traffic.\n3. **ISP Proxy**: Internet service providers (ISPs) can install proxy servers to reduce traffic going in and out of their networks.\n\n#### Example of Proxy Server Usage:\n\nIn a company network, a proxy server is installed locally. When any client in the network sends an HTTP request, it is first directed to the proxy server. If the proxy has the requested web page, it responds directly. If not, it forwards the request to the original web server, caches the response, and then sends it to the client.\n\n#### Cache Update Strategies:\n\n- **Site-Specific Caching**: Some sites update content at predictable intervals (e.g., news sites updating daily). The proxy server can cache the content until the next update.\n- **Last Modification Header**: Web responses can include headers indicating the last modification time. Proxy servers can use this information to determine how long the cached response is valid.",
			"styleAttributes":{},
			"x":3257,
			"y":5960,
			"width":1425,
			"height":560,
			"color":"3"
		},
		{
			"id":"91ee2da0f7b36cc0",
			"type":"file",
			"file":"source-images/Pasted image 20240901031214.png",
			"styleAttributes":{},
			"x":-140,
			"y":1140,
			"width":600,
			"height":307,
			"color":"6"
		},
		{
			"id":"eea59aa87f5b939c",
			"type":"text",
			"text":"### HTTP Security:\n\nBy itself, HTTP does not provide security features. However, when run over Secure Socket Layer (SSL), it becomes **HTTPS**, which provides confidentiality, authentication (both client and server), and data integrity.",
			"styleAttributes":{},
			"x":2302,
			"y":4495,
			"width":560,
			"height":180,
			"color":"3"
		},
		{
			"id":"01bf3a6f7a6e43d3",
			"type":"text",
			"text":"### Peer-to-Peer (P2P) Paradigm\n\nThe **peer-to-peer paradigm** (P2P) is a more recent model that decentralizes the communication process, allowing each participating computer, or \"peer,\" to act as both a client and a server. In this paradigm, no central server is required; instead, each peer can provide and receive services. This model is highly scalable and cost-effective, as it eliminates the need for a powerful central server. Examples of P2P applications include file-sharing services like BitTorrent, communication platforms like Skype, and Internet telephony. One of the main advantages of the P2P model is its resilience and efficiency in distributing tasks across multiple peers, reducing the burden on any single machine. However, it also presents challenges, particularly in terms of security and applicability. Ensuring secure communication between distributed peers is more complex than managing security in a centralized server setup. Additionally, not all applications are well-suited for this model, and widespread adoption of P2P for services like the World Wide Web may face resistance from users who are unwilling to share their resources as peers.",
			"styleAttributes":{
				"shape":null
			},
			"x":-160,
			"y":629,
			"width":590,
			"height":400,
			"color":"6"
		},
		{
			"id":"5934cd7c3e484256",
			"type":"text",
			"text":"### Application-Layer Paradigms\n\n\n",
			"styleAttributes":{},
			"x":-700,
			"y":470,
			"width":280,
			"height":100,
			"color":"1"
		},
		{
			"id":"22ef2a77e4975950",
			"type":"text",
			"text":"### Mixed Paradigm \nIt is the where where both is used so that the advantage of both can be used ",
			"styleAttributes":{},
			"x":-790,
			"y":695,
			"width":340,
			"height":156,
			"color":"6"
		},
		{
			"id":"7fdac9dad11b92b8",
			"type":"file",
			"file":"source-images/Pasted image 20240901030312.png",
			"styleAttributes":{},
			"x":-650,
			"y":-40,
			"width":400,
			"height":365
		},
		{
			"id":"bccd321d3d36096b",
			"type":"file",
			"file":"source-images/Pasted image 20240901031254.png",
			"styleAttributes":{},
			"x":-116,
			"y":11,
			"width":553,
			"height":263
		},
		{
			"id":"f0728bb66d12c011",
			"type":"text",
			"text":"### Standard Client-Server Applications\n\n**Overview:**  \nThroughout the history of the Internet, numerous client-server applications have been developed. While it is not necessary to redefine these applications, understanding their functions and options is crucial. This knowledge helps in creating customized applications in the future by learning from established protocols and services.",
			"styleAttributes":{},
			"x":-620,
			"y":2666,
			"width":605,
			"height":273,
			"color":"1"
		},
		{
			"id":"aad5451659e99fe9",
			"type":"text",
			"text":" **Nonstandard Application-Layer Protocols**: Programmers can create nonstandard or proprietary application-layer protocols by writing two programs that interact with the transport layer to provide specific services. These protocols do not require approval from Internet authorities if used privately, making the Internet highly adaptable. For example, a private company can develop a customized application protocol to facilitate communication between its global offices using the lower layers of the TCP/IP protocol suite without relying on standard application protocols.",
			"styleAttributes":{
				"textAlign":null
			},
			"x":-220,
			"y":-397,
			"width":640,
			"height":237,
			"color":"6"
		}
	],
	"edges":[
		{"id":"cdf6909b9de6bb4a","fromNode":"5a7be39ba04c3912","fromSide":"right","toNode":"6ca6feaaed0a5625","toSide":"left","color":"1"},
		{"id":"44139867d3fbceb5","fromNode":"5a7be39ba04c3912","fromSide":"right","toNode":"aad5451659e99fe9","toSide":"left","color":"1"},
		{
			"id":"7d7501a9c8d816a7",
			"styleAttributes":{},
			"fromNode":"5934cd7c3e484256",
			"fromSide":"right",
			"toNode":"01bf3a6f7a6e43d3",
			"toSide":"left",
			"color":"1"
		},
		{
			"id":"8d322a3f8304168c",
			"styleAttributes":{},
			"fromNode":"5934cd7c3e484256",
			"fromSide":"right",
			"toNode":"6c223e55f2c1f661",
			"toSide":"left",
			"color":"1",
			"label":"paradigms"
		},
		{
			"id":"37d971e6bc07579e",
			"styleAttributes":{},
			"fromNode":"5934cd7c3e484256",
			"fromSide":"top",
			"toNode":"7fdac9dad11b92b8",
			"toSide":"bottom",
			"color":"1"
		},
		{
			"id":"5e44456d399be5e9",
			"styleAttributes":{},
			"fromNode":"5a7be39ba04c3912",
			"fromSide":"bottom",
			"toNode":"7fdac9dad11b92b8",
			"toSide":"top",
			"color":"1"
		},
		{
			"id":"0240559550a4eac7",
			"styleAttributes":{},
			"fromNode":"01bf3a6f7a6e43d3",
			"fromSide":"bottom",
			"toNode":"91ee2da0f7b36cc0",
			"toSide":"top",
			"color":"6"
		},
		{
			"id":"bf7a5004a7d73361",
			"styleAttributes":{},
			"fromNode":"6c223e55f2c1f661",
			"fromSide":"top",
			"toNode":"bccd321d3d36096b",
			"toSide":"bottom",
			"color":"1"
		},
		{
			"id":"8783dd804a0f5b6c",
			"styleAttributes":{},
			"fromNode":"5934cd7c3e484256",
			"fromSide":"bottom",
			"toNode":"22ef2a77e4975950",
			"toSide":"top",
			"color":"1"
		},
		{
			"id":"20c592e747a57040",
			"styleAttributes":{},
			"fromNode":"6c223e55f2c1f661",
			"fromSide":"right",
			"toNode":"d84fdfb520a86310",
			"toSide":"left",
			"color":"1"
		},
		{
			"id":"d46bb33ba33cc903",
			"styleAttributes":{},
			"fromNode":"64949953cf8e0a8a",
			"fromSide":"right",
			"toNode":"f79eb2570927b718",
			"toSide":"left",
			"color":"3"
		},
		{
			"id":"129fa9c64f6f4f98",
			"styleAttributes":{},
			"fromNode":"ae0dec9c42fdeedd",
			"fromSide":"right",
			"toNode":"f79eb2570927b718",
			"toSide":"left",
			"color":"3"
		},
		{
			"id":"f9539452b76e8d21",
			"styleAttributes":{},
			"fromNode":"64949953cf8e0a8a",
			"fromSide":"right",
			"toNode":"56ba9c409828ba36",
			"toSide":"left",
			"color":"3"
		},
		{
			"id":"b8b37e8c8e6ddf9a",
			"styleAttributes":{},
			"fromNode":"84d69d572d0bcf1e",
			"fromSide":"right",
			"toNode":"45ab0c338b661c4b",
			"toSide":"left",
			"color":"2"
		},
		{
			"id":"87f5b45dcda5dee5",
			"styleAttributes":{},
			"fromNode":"1d4c252ade05e56c",
			"fromSide":"right",
			"toNode":"b20620d0f93726d3",
			"toSide":"left",
			"color":"2"
		},
		{
			"id":"93dce9bf8e81f5b1",
			"styleAttributes":{},
			"fromNode":"1d4c252ade05e56c",
			"fromSide":"right",
			"toNode":"f98219b8452c2560",
			"toSide":"left",
			"color":"2"
		},
		{
			"id":"89d5f43486cd3d98",
			"styleAttributes":{},
			"fromNode":"4e886663467051f9",
			"fromSide":"right",
			"toNode":"df2ee1f68c864ab8",
			"toSide":"left",
			"color":"6"
		},
		{
			"id":"9d413eabc72e819f",
			"styleAttributes":{},
			"fromNode":"4e886663467051f9",
			"fromSide":"right",
			"toNode":"1d4c252ade05e56c",
			"toSide":"left",
			"color":"6"
		},
		{
			"id":"5771ba5a0963e20c",
			"styleAttributes":{},
			"fromNode":"df2ee1f68c864ab8",
			"fromSide":"top",
			"toNode":"eb82233a9b0830d1",
			"toSide":"bottom",
			"color":"2"
		},
		{
			"id":"a823c52bf200109a",
			"styleAttributes":{},
			"fromNode":"df2ee1f68c864ab8",
			"fromSide":"top",
			"toNode":"eb82233a9b0830d1",
			"toSide":"bottom",
			"color":"2"
		},
		{
			"id":"bfa12a24fef8214c",
			"styleAttributes":{},
			"fromNode":"5bd9d68658434faa",
			"fromSide":"right",
			"toNode":"912f595d46388ad3",
			"toSide":"left",
			"color":"2"
		},
		{
			"id":"ea76a9411da0e2a9",
			"styleAttributes":{},
			"fromNode":"5bd9d68658434faa",
			"fromSide":"right",
			"toNode":"f21b53ba448c71f3",
			"toSide":"left",
			"color":"2"
		},
		{
			"id":"5e7e2c6c93a7adbd",
			"styleAttributes":{},
			"fromNode":"5bd9d68658434faa",
			"fromSide":"right",
			"toNode":"141e625fbb7fd024",
			"toSide":"left",
			"color":"2"
		},
		{
			"id":"d88707f190fe8811",
			"styleAttributes":{},
			"fromNode":"5bd9d68658434faa",
			"fromSide":"right",
			"toNode":"6583d437f488c9ec",
			"toSide":"left",
			"color":"2"
		},
		{
			"id":"9b67640a568d6eaf",
			"styleAttributes":{},
			"fromNode":"5bd9d68658434faa",
			"fromSide":"bottom",
			"toNode":"eea59aa87f5b939c",
			"toSide":"top",
			"color":"2"
		},
		{
			"id":"969f908472532a23",
			"styleAttributes":{},
			"fromNode":"4e886663467051f9",
			"fromSide":"right",
			"toNode":"5bd9d68658434faa",
			"toSide":"left",
			"color":"6"
		},
		{
			"id":"e4f3625180752b9a",
			"styleAttributes":{},
			"fromNode":"f0728bb66d12c011",
			"fromSide":"right",
			"toNode":"4e886663467051f9",
			"toSide":"left",
			"color":"1"
		},
		{
			"id":"e32c0d4558d82e9c",
			"styleAttributes":{},
			"fromNode":"f0728bb66d12c011",
			"fromSide":"right",
			"toNode":"1899c956b2cf869c",
			"toSide":"left",
			"color":"1"
		},
		{
			"id":"da16b13fe3d68a23",
			"styleAttributes":{},
			"fromNode":"1899c956b2cf869c",
			"fromSide":"right",
			"toNode":"a078b64a872808e9",
			"toSide":"left",
			"color":"6"
		},
		{
			"id":"985d694ab56e9609",
			"styleAttributes":{},
			"fromNode":"1899c956b2cf869c",
			"fromSide":"right",
			"toNode":"c012cda824b37967",
			"toSide":"left",
			"color":"6"
		},
		{
			"id":"e9377d1f371c9f05",
			"styleAttributes":{},
			"fromNode":"a078b64a872808e9",
			"fromSide":"left",
			"toNode":"d6913325504cb209",
			"toSide":"right",
			"color":"2"
		},
		{
			"id":"d79789e5fb25ff50",
			"styleAttributes":{},
			"fromNode":"1899c956b2cf869c",
			"fromSide":"right",
			"toNode":"5ad1a09e4b60a0a9",
			"toSide":"left",
			"color":"6"
		},
		{
			"id":"5365516f385439ac",
			"styleAttributes":{},
			"fromNode":"c012cda824b37967",
			"fromSide":"left",
			"toNode":"f326a2acc892975b",
			"toSide":"right",
			"color":"2"
		},
		{
			"id":"586f8152a524f25e",
			"styleAttributes":{},
			"fromNode":"5ad1a09e4b60a0a9",
			"fromSide":"left",
			"toNode":"f326a2acc892975b",
			"toSide":"right",
			"color":"2"
		},
		{
			"id":"5f77f882b4d8cd9e",
			"styleAttributes":{},
			"fromNode":"5ad1a09e4b60a0a9",
			"fromSide":"right",
			"toNode":"4fcf5ba121484db9",
			"toSide":"left",
			"color":"2"
		},
		{
			"id":"26778be5c0d73e8d",
			"styleAttributes":{},
			"fromNode":"d3151340a6379e96",
			"fromSide":"right",
			"toNode":"d9ebc934d82e6cdc",
			"toSide":"left",
			"color":"2"
		},
		{
			"id":"d58ae121ba2076bf",
			"styleAttributes":{},
			"fromNode":"d3151340a6379e96",
			"fromSide":"right",
			"toNode":"1862480d07046e0a",
			"toSide":"left",
			"color":"2"
		},
		{
			"id":"c6b811e8dee81496",
			"styleAttributes":{},
			"fromNode":"d3151340a6379e96",
			"fromSide":"right",
			"toNode":"89f62c6019dff2d8",
			"toSide":"left",
			"color":"2"
		},
		{
			"id":"ab3bfcf49cddd2cc",
			"styleAttributes":{},
			"fromNode":"f0728bb66d12c011",
			"fromSide":"right",
			"toNode":"358d37436ccbcb44",
			"toSide":"left",
			"color":"1"
		},
		{
			"id":"8f020024bb05532a",
			"styleAttributes":{},
			"fromNode":"358d37436ccbcb44",
			"fromSide":"bottom",
			"toNode":"cdd777d573f45fe0",
			"toSide":"top",
			"color":"6"
		},
		{
			"id":"a0a066f2f6fdaa4c",
			"styleAttributes":{},
			"fromNode":"ae3ac72c64a68d3a",
			"fromSide":"right",
			"toNode":"6a450685f2d559ae",
			"toSide":"left",
			"color":"2"
		},
		{
			"id":"bfd220672a15cbe6",
			"styleAttributes":{},
			"fromNode":"ae3ac72c64a68d3a",
			"fromSide":"right",
			"toNode":"6a6850e944b1b137",
			"toSide":"left",
			"color":"2"
		},
		{
			"id":"ff6485d8d47de601",
			"styleAttributes":{},
			"fromNode":"ae3ac72c64a68d3a",
			"fromSide":"right",
			"toNode":"9bdb09bc9b3c96d1",
			"toSide":"top",
			"color":"2"
		},
		{
			"id":"0401ee5b33e8372e",
			"styleAttributes":{},
			"fromNode":"ae3ac72c64a68d3a",
			"fromSide":"right",
			"toNode":"5ddef9b739fa8e88",
			"toSide":"top",
			"color":"2"
		},
		{
			"id":"916145d2266ee100",
			"styleAttributes":{},
			"fromNode":"ae3ac72c64a68d3a",
			"fromSide":"right",
			"toNode":"ba65d3d00f4e0abb",
			"toSide":"left",
			"color":"2"
		},
		{
			"id":"45297cef5f57437b",
			"styleAttributes":{},
			"fromNode":"ba65d3d00f4e0abb",
			"fromSide":"right",
			"toNode":"45e66013b277599f",
			"toSide":"left"
		},
		{
			"id":"46a995a946406de6",
			"styleAttributes":{},
			"fromNode":"45e66013b277599f",
			"fromSide":"bottom",
			"toNode":"663d7945e8580e33",
			"toSide":"top",
			"color":"4"
		},
		{
			"id":"84008f2d60dbc14d",
			"styleAttributes":{},
			"fromNode":"45e66013b277599f",
			"fromSide":"bottom",
			"toNode":"51bdd7a206320b54",
			"toSide":"top",
			"color":"4"
		},
		{
			"id":"e8fccb45f6a2d5e2",
			"styleAttributes":{},
			"fromNode":"ad7e2a06eb48e1b8",
			"fromSide":"right",
			"toNode":"fabc026b12de2e84",
			"toSide":"left",
			"color":"3"
		},
		{
			"id":"ab12b5eba1f6ddf0",
			"styleAttributes":{},
			"fromNode":"ad7e2a06eb48e1b8",
			"fromSide":"right",
			"toNode":"4fa0a4df363e13be",
			"toSide":"left",
			"color":"3"
		},
		{
			"id":"d23f88872fb37bc9",
			"styleAttributes":{},
			"fromNode":"ad7e2a06eb48e1b8",
			"fromSide":"right",
			"toNode":"e38d5692cb80970a",
			"toSide":"left",
			"color":"3"
		},
		{
			"id":"583f9e74da5dcae0",
			"styleAttributes":{},
			"fromNode":"fabc026b12de2e84",
			"fromSide":"bottom",
			"toNode":"a40b565e13099b27",
			"toSide":"top",
			"color":"4"
		},
		{
			"id":"808b930d08cf6f48",
			"styleAttributes":{},
			"fromNode":"4fa0a4df363e13be",
			"fromSide":"top",
			"toNode":"a40b565e13099b27",
			"toSide":"bottom",
			"color":"4"
		},
		{
			"id":"cf4637e6c2a042ba",
			"styleAttributes":{},
			"fromNode":"fabc026b12de2e84",
			"fromSide":"right",
			"toNode":"58d0c7e821bd2f1b",
			"toSide":"left",
			"color":"4"
		},
		{
			"id":"51b3659ffb72bf9c",
			"styleAttributes":{},
			"fromNode":"4fa0a4df363e13be",
			"fromSide":"right",
			"toNode":"8156b6e7aacdfc5b",
			"toSide":"left",
			"color":"4"
		},
		{
			"id":"49964b9c12bba699",
			"styleAttributes":{},
			"fromNode":"ae3ac72c64a68d3a",
			"fromSide":"right",
			"toNode":"ad7e2a06eb48e1b8",
			"toSide":"left",
			"color":"2"
		},
		{
			"id":"9ad5782c59922740",
			"styleAttributes":{},
			"fromNode":"ae3ac72c64a68d3a",
			"fromSide":"right",
			"toNode":"f559e0925c8e254f",
			"toSide":"left",
			"color":"2"
		},
		{
			"id":"baa9380dd3b2ebee",
			"styleAttributes":{},
			"fromNode":"e544be4853118a81",
			"fromSide":"right",
			"toNode":"6f0b3f8ffd61203b",
			"toSide":"left",
			"color":"2"
		},
		{
			"id":"61e1eed416f97ba3",
			"styleAttributes":{},
			"fromNode":"358d37436ccbcb44",
			"fromSide":"right",
			"toNode":"ae3ac72c64a68d3a",
			"toSide":"left",
			"color":"6"
		},
		{
			"id":"2c821e372fa80ab2",
			"styleAttributes":{},
			"fromNode":"5934cd7c3e484256",
			"fromSide":"left",
			"toNode":"c3107ec0630a9f66",
			"toSide":"left",
			"color":"1",
			"label":"providing services"
		}
	],
	"metadata":{}
}